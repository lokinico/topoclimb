#!/usr/bin/env node\n\n/**\n * TopoclimbCH JavaScript Build Script\n * Simple build system pour optimiser les fichiers JS\n * \n * Usage: node build.js [--production] [--watch]\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\nclass TopoclimbBuildSystem {\n    constructor() {\n        this.projectRoot = path.resolve(__dirname);\n        this.buildDir = path.join(this.projectRoot, 'dist');\n        this.isProduction = process.argv.includes('--production');\n        this.isWatching = process.argv.includes('--watch');\n        \n        this.config = {\n            // Fichiers à bundler ensemble (ordre important)\n            bundles: {\n                'topoclimb-core.js': [\n                    'core/index.js',\n                    'core/utils.js',\n                    'core/api.js',\n                    'core/ui.js'\n                ],\n                'topoclimb-components.js': [\n                    'utils/coordinates-helper.js',\n                    'components/swiss-map-manager.js',\n                    'components/interactive-map-manager.js',\n                    'components/region-map.js',\n                    'components/weather-widget.js',\n                    'components/geolocation-manager.js',\n                    'components/site-form-manager.js'\n                ],\n                'topoclimb-pages.js': [\n                    'pages/regions/show-modern.js'\n                ]\n            },\n            \n            // Fichiers à copier tels quels\n            standalone: [\n                'topoclimb.js',\n                'common.js',\n                'analytics.js'\n            ],\n            \n            // Optimisations\n            minify: true,\n            sourcemaps: true,\n            removeComments: true,\n            removeConsole: false // Garder les console.log en dev\n        };\n    }\n    \n    async build() {\n        console.log('🏗️  Starting TopoclimbCH build...');\n        console.log(`📁 Project root: ${this.projectRoot}`);\n        console.log(`🎯 Environment: ${this.isProduction ? 'production' : 'development'}`);\n        \n        try {\n            // Créer le dossier de build\n            this.ensureBuildDir();\n            \n            // Générer les bundles\n            await this.generateBundles();\n            \n            // Copier les fichiers standalone\n            await this.copyStandaloneFiles();\n            \n            // Générer les métadonnées\n            await this.generateMetadata();\n            \n            // Créer le fichier de version\n            await this.generateVersionFile();\n            \n            console.log('✅ Build completed successfully!');\n            \n            if (this.isWatching) {\n                this.startWatcher();\n            }\n            \n        } catch (error) {\n            console.error('❌ Build failed:', error.message);\n            process.exit(1);\n        }\n    }\n    \n    ensureBuildDir() {\n        if (!fs.existsSync(this.buildDir)) {\n            fs.mkdirSync(this.buildDir, { recursive: true });\n            console.log(`📁 Created build directory: ${this.buildDir}`);\n        }\n    }\n    \n    async generateBundles() {\n        console.log('📦 Generating bundles...');\n        \n        for (const [bundleName, files] of Object.entries(this.config.bundles)) {\n            const bundleContent = await this.bundleFiles(files);\n            const outputPath = path.join(this.buildDir, bundleName);\n            \n            // Écrire le bundle\n            fs.writeFileSync(outputPath, bundleContent);\n            \n            // Minifier si nécessaire\n            if (this.isProduction && this.config.minify) {\n                const minifiedContent = this.minifyJs(bundleContent);\n                const minPath = outputPath.replace('.js', '.min.js');\n                fs.writeFileSync(minPath, minifiedContent);\n                console.log(`📦 Bundle created: ${bundleName} (${this.getFileSize(outputPath)} -> ${this.getFileSize(minPath)})`);\n            } else {\n                console.log(`📦 Bundle created: ${bundleName} (${this.getFileSize(outputPath)})`);\n            }\n        }\n    }\n    \n    async bundleFiles(files) {\n        const bundleContent = [];\n        \n        // Header du bundle\n        bundleContent.push(`/**\n * TopoclimbCH Bundle\n * Generated: ${new Date().toISOString()}\n * Environment: ${this.isProduction ? 'production' : 'development'}\n * Files: ${files.join(', ')}\n */`);\n        \n        bundleContent.push('(function() {');\n        bundleContent.push('\"use strict\";');\n        \n        // Concaténer les fichiers\n        for (const file of files) {\n            const filePath = path.join(this.projectRoot, file);\n            \n            if (!fs.existsSync(filePath)) {\n                console.warn(`⚠️  File not found: ${file}`);\n                continue;\n            }\n            \n            const content = fs.readFileSync(filePath, 'utf-8');\n            bundleContent.push(`\\n/* === ${file} === */`);\n            bundleContent.push(content);\n        }\n        \n        bundleContent.push('})();');\n        \n        return bundleContent.join('\\n');\n    }\n    \n    async copyStandaloneFiles() {\n        console.log('📄 Copying standalone files...');\n        \n        for (const file of this.config.standalone) {\n            const sourcePath = path.join(this.projectRoot, file);\n            const destPath = path.join(this.buildDir, file);\n            \n            if (!fs.existsSync(sourcePath)) {\n                console.warn(`⚠️  Standalone file not found: ${file}`);\n                continue;\n            }\n            \n            let content = fs.readFileSync(sourcePath, 'utf-8');\n            \n            // Optimisations pour la production\n            if (this.isProduction) {\n                if (this.config.removeComments) {\n                    content = this.removeComments(content);\n                }\n                if (this.config.removeConsole) {\n                    content = this.removeConsoleStatements(content);\n                }\n            }\n            \n            fs.writeFileSync(destPath, content);\n            \n            // Version minifiée pour la production\n            if (this.isProduction && this.config.minify) {\n                const minContent = this.minifyJs(content);\n                const minPath = destPath.replace('.js', '.min.js');\n                fs.writeFileSync(minPath, minContent);\n                console.log(`📄 Copied: ${file} (${this.getFileSize(destPath)} -> ${this.getFileSize(minPath)})`);\n            } else {\n                console.log(`📄 Copied: ${file} (${this.getFileSize(destPath)})`);\n            }\n        }\n    }\n    \n    minifyJs(content) {\n        // Minification basique (pour une vraie minification, utiliser UglifyJS ou Terser)\n        return content\n            // Supprimer les commentaires\n            .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n            .replace(/\\/\\/.*$/gm, '')\n            // Supprimer les espaces multiples\n            .replace(/\\s+/g, ' ')\n            // Supprimer les espaces autour des opérateurs\n            .replace(/\\s*([{}();,])\\s*/g, '$1')\n            // Supprimer les lignes vides\n            .replace(/\\n\\s*\\n/g, '\\n')\n            .trim();\n    }\n    \n    removeComments(content) {\n        return content\n            .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n            .replace(/\\/\\/.*$/gm, '');\n    }\n    \n    removeConsoleStatements(content) {\n        return content.replace(/console\\.[log|warn|error|info|debug]\\(.*?\\);?/g, '');\n    }\n    \n    async generateMetadata() {\n        const metadata = {\n            version: '2.0.0',\n            buildTime: new Date().toISOString(),\n            environment: this.isProduction ? 'production' : 'development',\n            bundles: {},\n            standalone: {},\n            totalSize: 0\n        };\n        \n        // Métadonnées des bundles\n        for (const bundleName of Object.keys(this.config.bundles)) {\n            const bundlePath = path.join(this.buildDir, bundleName);\n            const minPath = bundlePath.replace('.js', '.min.js');\n            \n            metadata.bundles[bundleName] = {\n                size: this.getFileSizeBytes(bundlePath),\n                sizeFormatted: this.getFileSize(bundlePath),\n                minSize: fs.existsSync(minPath) ? this.getFileSizeBytes(minPath) : null,\n                minSizeFormatted: fs.existsSync(minPath) ? this.getFileSize(minPath) : null\n            };\n            \n            metadata.totalSize += metadata.bundles[bundleName].size;\n        }\n        \n        // Métadonnées des fichiers standalone\n        for (const fileName of this.config.standalone) {\n            const filePath = path.join(this.buildDir, fileName);\n            const minPath = filePath.replace('.js', '.min.js');\n            \n            if (fs.existsSync(filePath)) {\n                metadata.standalone[fileName] = {\n                    size: this.getFileSizeBytes(filePath),\n                    sizeFormatted: this.getFileSize(filePath),\n                    minSize: fs.existsSync(minPath) ? this.getFileSizeBytes(minPath) : null,\n                    minSizeFormatted: fs.existsSync(minPath) ? this.getFileSize(minPath) : null\n                };\n                \n                metadata.totalSize += metadata.standalone[fileName].size;\n            }\n        }\n        \n        metadata.totalSizeFormatted = this.formatBytes(metadata.totalSize);\n        \n        // Écrire les métadonnées\n        const metadataPath = path.join(this.buildDir, 'build-metadata.json');\n        fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));\n        \n        console.log(`📊 Total bundle size: ${metadata.totalSizeFormatted}`);\n    }\n    \n    async generateVersionFile() {\n        const version = {\n            version: '2.0.0',\n            buildTime: new Date().toISOString(),\n            gitCommit: this.getGitCommit(),\n            environment: this.isProduction ? 'production' : 'development'\n        };\n        \n        const versionJs = `\n// TopoclimbCH Version Info\nwindow.TopoclimbCH = window.TopoclimbCH || {};\nwindow.TopoclimbCH.buildInfo = ${JSON.stringify(version, null, 2)};\nconsole.log('📦 TopoclimbCH v' + window.TopoclimbCH.buildInfo.version + ' (build: ' + window.TopoclimbCH.buildInfo.buildTime + ')');\n        `.trim();\n        \n        fs.writeFileSync(path.join(this.buildDir, 'version.js'), versionJs);\n    }\n    \n    getGitCommit() {\n        try {\n            return execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).trim();\n        } catch (e) {\n            return 'unknown';\n        }\n    }\n    \n    getFileSize(filePath) {\n        if (!fs.existsSync(filePath)) return '0 B';\n        const bytes = fs.statSync(filePath).size;\n        return this.formatBytes(bytes);\n    }\n    \n    getFileSizeBytes(filePath) {\n        if (!fs.existsSync(filePath)) return 0;\n        return fs.statSync(filePath).size;\n    }\n    \n    formatBytes(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    }\n    \n    startWatcher() {\n        console.log('👀 Starting file watcher...');\n        \n        const chokidar = require('chokidar');\n        const watcher = chokidar.watch([\n            'core/**/*.js',\n            'components/**/*.js',\n            'utils/**/*.js',\n            'pages/**/*.js',\n            '*.js'\n        ], {\n            ignored: ['dist/**', 'node_modules/**'],\n            cwd: this.projectRoot\n        });\n        \n        watcher.on('change', (filePath) => {\n            console.log(`🔄 File changed: ${filePath}`);\n            this.build().catch(console.error);\n        });\n        \n        console.log('👀 File watcher started. Press Ctrl+C to stop.');\n    }\n}\n\n// Exécution\nif (require.main === module) {\n    const builder = new TopoclimbBuildSystem();\n    builder.build().catch(console.error);\n}\n\nmodule.exports = TopoclimbBuildSystem;
/**
 * RegionMapManager - Gestionnaire de carte pour pages r√©gion
 * Extrait et modularis√© depuis pages/regions/show.js
 */

// Enregistrement du module RegionMap
TopoclimbCH.modules.register('region-map', ['utils', 'api'], (utils, api) => {
    
    class RegionMapManager {
        constructor(containerId, options = {}) {\n            this.containerId = containerId;\n            this.options = {\n                center: [46.8182, 8.2275],\n                zoom: 10,\n                showLayers: {\n                    sectors: true,\n                    hiking: true,\n                    parking: true\n                },\n                ...options\n            };\n            \n            this.map = null;\n            this.layers = new Map();\n            this.activeLayer = 'sectors';\n            this.routingControl = null;\n            this.isRoutingActive = false;\n            \n            this.regionData = options.regionData || null;\n            this.sectors = options.sectors || [];\n        }\n        \n        /**\n         * Initialise la carte\n         */\n        init() {\n            if (!this.regionData) {\n                console.warn('No region data provided for map');\n                return;\n            }\n            \n            this.createMap();\n            this.addBaseLayers();\n            this.addSectorMarkers();\n            this.setupLayerControls();\n            this.setupRoutingControls();\n            \n            console.log('üó∫Ô∏è RegionMapManager initialized');\n        }\n        \n        /**\n         * Cr√©e la carte Leaflet\n         */\n        createMap() {\n            const center = this.regionData.coordinates_lat && this.regionData.coordinates_lng ?\n                          [this.regionData.coordinates_lat, this.regionData.coordinates_lng] :\n                          this.options.center;\n            \n            this.map = L.map(this.containerId, {\n                center,\n                zoom: this.options.zoom,\n                zoomControl: false\n            });\n            \n            // Contr√¥les de zoom personnalis√©s\n            L.control.zoom({ position: 'topright' }).addTo(this.map);\n        }\n        \n        /**\n         * Ajoute les couches de base\n         */\n        addBaseLayers() {\n            // Couche Swisstopo par d√©faut\n            const swisstopoLayer = L.tileLayer(\n                'https://wmts.geo.admin.ch/1.0.0/ch.swisstopo.pixelkarte-farbe/default/current/3857/{z}/{x}/{y}.jpeg',\n                {\n                    attribution: '¬© swisstopo',\n                    maxZoom: 18\n                }\n            ).addTo(this.map);\n            \n            // Couche satellite\n            const satelliteLayer = L.tileLayer(\n                'https://wmts.geo.admin.ch/1.0.0/ch.swisstopo.swissimage/default/current/3857/{z}/{x}/{y}.jpeg',\n                {\n                    attribution: '¬© swisstopo',\n                    maxZoom: 18\n                }\n            );\n            \n            // Couche randonn√©e\n            const hikingLayer = L.tileLayer(\n                'https://wmts.geo.admin.ch/1.0.0/ch.swisstopo.wanderkarten500/default/current/3857/{z}/{x}/{y}.jpeg',\n                {\n                    attribution: '¬© swisstopo',\n                    maxZoom: 18\n                }\n            );\n            \n            this.layers.set('base', swisstopoLayer);\n            this.layers.set('satellite', satelliteLayer);\n            this.layers.set('hiking', hikingLayer);\n            \n            // Contr√¥le des couches\n            const baseLayers = {\n                'Carte couleur': swisstopoLayer,\n                'Satellite': satelliteLayer,\n                'Randonn√©e': hikingLayer\n            };\n            \n            L.control.layers(baseLayers).addTo(this.map);\n        }\n        \n        /**\n         * Ajoute les marqueurs des secteurs\n         */\n        addSectorMarkers() {\n            const sectorsGroup = L.layerGroup();\n            \n            this.sectors.forEach(sector => {\n                if (!sector.coordinates_lat || !sector.coordinates_lng) return;\n                \n                const marker = L.circleMarker(\n                    [sector.coordinates_lat, sector.coordinates_lng],\n                    {\n                        radius: 8,\n                        fillColor: this.getSectorColor(sector),\n                        color: '#ffffff',\n                        weight: 2,\n                        opacity: 1,\n                        fillOpacity: 0.8\n                    }\n                );\n                \n                marker.bindPopup(this.createSectorPopup(sector));\n                sectorsGroup.addLayer(marker);\n            });\n            \n            sectorsGroup.addTo(this.map);\n            this.layers.set('sectors', sectorsGroup);\n            \n            // Ajuster la vue pour contenir tous les secteurs\n            if (this.sectors.length > 0) {\n                const bounds = sectorsGroup.getBounds();\n                if (bounds.isValid()) {\n                    this.map.fitBounds(bounds, { padding: [20, 20] });\n                }\n            }\n        }\n        \n        /**\n         * D√©termine la couleur d'un secteur selon sa difficult√©\n         */\n        getSectorColor(sector) {\n            // Couleurs bas√©es sur la difficult√© moyenne\n            const difficulty = sector.avg_difficulty || 0;\n            \n            if (difficulty <= 4) return '#22c55e'; // Vert - Facile\n            if (difficulty <= 6) return '#eab308'; // Jaune - Moyen\n            if (difficulty <= 7) return '#f97316'; // Orange - Difficile\n            return '#ef4444'; // Rouge - Tr√®s difficile\n        }\n        \n        /**\n         * Cr√©e le popup d'un secteur\n         */\n        createSectorPopup(sector) {\n            return `\n                <div class=\"sector-popup\">\n                    <h6 class=\"sector-name\">\n                        <i class=\"fa fa-mountain\"></i>\n                        ${utils.escapeHtml(sector.name)}\n                    </h6>\n                    <div class=\"sector-info\">\n                        <div class=\"info-row\">\n                            <span class=\"label\">Voies:</span>\n                            <span class=\"value\">${sector.route_count || 0}</span>\n                        </div>\n                        <div class=\"info-row\">\n                            <span class=\"label\">Difficult√©:</span>\n                            <span class=\"value\">${sector.difficulty_range || 'N/A'}</span>\n                        </div>\n                        <div class=\"info-row\">\n                            <span class=\"label\">Orientation:</span>\n                            <span class=\"value\">${sector.orientation || 'N/A'}</span>\n                        </div>\n                    </div>\n                    <div class=\"sector-actions\">\n                        <a href=\"/sectors/${sector.id}\" class=\"btn btn-sm btn-primary\">\n                            <i class=\"fa fa-info-circle\"></i> D√©tails\n                        </a>\n                        <button onclick=\"this.showDirections(${sector.id})\" class=\"btn btn-sm btn-success\">\n                            <i class=\"fa fa-route\"></i> Itin√©raire\n                        </button>\n                    </div>\n                </div>\n            `;\n        }\n        \n        /**\n         * Configuration des contr√¥les de couches\n         */\n        setupLayerControls() {\n            const controls = {\n                'btn-sectors': 'sectors',\n                'btn-hiking': 'hiking',\n                'btn-parking': 'parking'\n            };\n            \n            Object.keys(controls).forEach(btnId => {\n                const button = document.getElementById(btnId);\n                if (button) {\n                    button.addEventListener('click', () => {\n                        this.toggleLayer(controls[btnId]);\n                        this.updateActiveButton(btnId);\n                    });\n                }\n            });\n        }\n        \n        /**\n         * Active/d√©sactive une couche\n         */\n        toggleLayer(layerName) {\n            const layer = this.layers.get(layerName);\n            if (!layer) return;\n            \n            if (this.map.hasLayer(layer)) {\n                this.map.removeLayer(layer);\n            } else {\n                layer.addTo(this.map);\n            }\n            \n            this.activeLayer = layerName;\n        }\n        \n        /**\n         * Met √† jour le bouton actif\n         */\n        updateActiveButton(activeButtonId) {\n            document.querySelectorAll('.map-layer-btn').forEach(btn => {\n                btn.classList.remove('active');\n            });\n            \n            const activeBtn = document.getElementById(activeButtonId);\n            if (activeBtn) {\n                activeBtn.classList.add('active');\n            }\n        }\n        \n        /**\n         * Configuration des contr√¥les de routage\n         */\n        setupRoutingControls() {\n            const routeBtn = document.getElementById('btn-route');\n            if (routeBtn) {\n                routeBtn.addEventListener('click', () => {\n                    this.toggleRouting();\n                });\n            }\n        }\n        \n        /**\n         * Active/d√©sactive le routage\n         */\n        toggleRouting() {\n            if (this.isRoutingActive) {\n                this.disableRouting();\n            } else {\n                this.enableRouting();\n            }\n        }\n        \n        /**\n         * Active le mode routage\n         */\n        enableRouting() {\n            if (!navigator.geolocation) {\n                TopoclimbCH.ui.toast.error('G√©olocalisation non disponible');\n                return;\n            }\n            \n            navigator.geolocation.getCurrentPosition(\n                (position) => {\n                    this.createRoute(\n                        [position.coords.latitude, position.coords.longitude],\n                        [this.regionData.coordinates_lat, this.regionData.coordinates_lng]\n                    );\n                },\n                (error) => {\n                    TopoclimbCH.ui.toast.error('Impossible d\\'obtenir votre position');\n                }\n            );\n        }\n        \n        /**\n         * Cr√©e un itin√©raire\n         */\n        async createRoute(start, end) {\n            try {\n                const response = await api.get('/api/routing/directions', {\n                    start: start.join(','),\n                    end: end.join(','),\n                    profile: 'driving'\n                });\n                \n                if (response.route) {\n                    this.displayRoute(response.route);\n                    this.isRoutingActive = true;\n                }\n            } catch (error) {\n                console.error('Routing error:', error);\n                TopoclimbCH.ui.toast.error('Erreur lors du calcul d\\'itin√©raire');\n            }\n        }\n        \n        /**\n         * Affiche un itin√©raire sur la carte\n         */\n        displayRoute(route) {\n            if (this.routingControl) {\n                this.map.removeControl(this.routingControl);\n            }\n            \n            const routeLine = L.polyline(route.coordinates, {\n                color: '#3b82f6',\n                weight: 4,\n                opacity: 0.8\n            }).addTo(this.map);\n            \n            this.map.fitBounds(routeLine.getBounds());\n            this.layers.set('route', routeLine);\n            \n            // Informations sur l'itin√©raire\n            const info = `\n                <div class=\"route-info\">\n                    <h6><i class=\"fa fa-route\"></i> Itin√©raire</h6>\n                    <p><strong>Distance:</strong> ${utils.formatDistance(route.distance / 1000)}</p>\n                    <p><strong>Dur√©e:</strong> ${utils.formatDuration(route.duration / 60)}</p>\n                </div>\n            `;\n            \n            TopoclimbCH.ui.toast.info(info, { duration: 10000 });\n        }\n        \n        /**\n         * D√©sactive le mode routage\n         */\n        disableRouting() {\n            if (this.routingControl) {\n                this.map.removeControl(this.routingControl);\n                this.routingControl = null;\n            }\n            \n            const routeLayer = this.layers.get('route');\n            if (routeLayer) {\n                this.map.removeLayer(routeLayer);\n                this.layers.delete('route');\n            }\n            \n            this.isRoutingActive = false;\n        }\n        \n        /**\n         * Affiche les directions vers un secteur\n         */\n        showDirections(sectorId) {\n            const sector = this.sectors.find(s => s.id === sectorId);\n            if (!sector) return;\n            \n            this.enableRouting();\n            this.createRoute(\n                [this.regionData.coordinates_lat, this.regionData.coordinates_lng],\n                [sector.coordinates_lat, sector.coordinates_lng]\n            );\n        }\n        \n        /**\n         * Centre la carte sur la r√©gion\n         */\n        centerOnRegion() {\n            if (this.regionData.coordinates_lat && this.regionData.coordinates_lng) {\n                this.map.setView(\n                    [this.regionData.coordinates_lat, this.regionData.coordinates_lng],\n                    this.options.zoom\n                );\n            }\n        }\n        \n        /**\n         * Obtient l'instance Leaflet\n         */\n        getLeafletMap() {\n            return this.map;\n        }\n        \n        /**\n         * Nettoyage\n         */\n        destroy() {\n            if (this.map) {\n                this.map.remove();\n                this.map = null;\n            }\n            \n            this.layers.clear();\n        }\n    }\n    \n    return RegionMapManager;\n});\n\nconsole.log('üó∫Ô∏è RegionMapManager module ready');